---
title: "Romic"
description: "An R package for exploratory data analysis of high-dimensional datasets"
author: sean
layout: post
comments: true
tags: [R, software]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Romic is an R package, which I developed, that is now is now available on [CRAN](https://cran.r-project.org/web/packages/romic/index.html). There is already a nice README for romic on [GitHub](https://github.com/calico/romic) and [pkgdown site](https://calico.github.io/romic/articles/romic.html), so here, I will add some context regarding the problems this package addresses.

The first problem we'll consider is that genomics data analysis involves a lot of shuffling between various forms of wide and tall data and incrementally tacking on attributes as needed. Romic aims to simplify this process, by providing a set of flexible data structures that accommodate a range of measurements and metadata and can be readily inter-converted based on the needs of an analysis. 

The second challenge we'll contend with is decreasing the time it takes to generate a plot so that mechanics of plotting rarely interrupt the thought process of data interpretation. Building upon romic's data structure, the meaning of variables (feature-, sample-, measurement-level) are encoded in a schema, so they can be appropriately surfaced to filter or reorder a dataset, and add ggplot2 aesthetics. Interactivity is facilitated using shiny apps composed from romic-centric shiny modules.

Both of these solutions increase the speed, clarity, and succinctness of analysis. I've developed and will continue to refine this package to save myself (and hopefully others!) time. 

While, romic is discussed in the parlance of genomics, romic's data structures are useful for any moderately sized feature-level data, and its interactive visualizations can be used for any data with dense continuous measurements. Because of its generality, romic serves as a useful underlying data structure that can be combined with application-specific schemas and methods to create powerful, succinct workflows. One such application that I'll discuss in a future post, is the [claman](https://github.com/calico/claman) R package which builds upon romic to create an opinionated workflow for mass spectrometry data analysis.

# Data Structures for Genomics

## Conventional Formatting

Datasets in genomics are generally generated and shared in wide formats (one row per gene, one column per sample), often with extra rows and columns added for feature and sample metadata. At first blush this is a good format, because it supports both folks who want to work with a matrix-level dataset as well as individuals who are interested in specific genes.

That said, to manipulate and visualize such data requires integrating metadata with measurements. For example, when correcting for batch effects we often want to incorporate sample-level information, such as the date samples were collected. Combining numeric measurements with categorical and numeric meta-data is awkward in matrices. One could do this with attributes, but generally we would just maintain separate tables for samples, and features, since each variable in a table can have its own class. A benefit of this approach is that working with matrices can be very fast, while the major downsides are having to maintain multiple similar versions of a dataset, and being careful about maintaining the alignment of measurements, features, and samples.

## Romic's Tabular Representations

An alternative to manipulating matrices is to work fully with tabular data. This mode of operation is very similar to working with sql, allowing us to maintain a complex, yet organized dataset. Using tabular, tidy, data also allow us to tap into the expansive suite of tools in the tidyverse. Working with features, samples, and measurements tables allow us to separately modify each table, while the three tables can be combined (using primary key - foreign key relationships) if we need to add sample- or feature-level context to measurements. 

Romic provides two data structures, a triple_omic an tidy_omic class for representing these two scenarios. These formats can be used interchangeable in romic's functions by treating them as a T*omics (tomic) meta-class. Most exported functions from romic, take a tomic object which means they can convert to whatever format makes most sense for a function under the hood and then return a triple_omic or tidy_omic object depending on the input type.

Using a schema, tables can be combined and then broken apart again without constant guidance, and validators quickly flag data manipulation errors (such as non-unique primary keys, or measurements of the same sample with different sample attributes).

By taking care of many of the joins and reshaping operations that we may have to do, romic helps to simplify analyses while avoid common data manipulation errors. It directly supports dplyr and some ggplot operations, while data can also be easily pulled out of the romic format (and then added back if desired) based on users' needs.

## Let's format a dataset

As a quick demo, we can look at published 

```{r env_setup, message = FALSE}
library(dplyr)
library(romic)

```



```{r}
gasche_2000 <- readr::read_tsv("http://www-genome.stanford.edu/yeast_stress/data/rawdata/complete_dataset.txt")
gasche_matrix <- gasche_2000 %>%
  select(-UID, -NAME, -GWEIGHT) %>%
  as.matrix()
rownames(gasche_matrix) <- gasche_2000$UID

print(dim(gasche_matrix))
```

### Process metadata

#### Genes

```{r feature_metadata}
goslim_mappings <- readr::read_tsv(
    "https://downloads.yeastgenome.org/curation/literature/go_slim_mapping.tab",
    col_names = c("ORF", "common", "SGD", "category", "geneset", "GO", "class")
  ) %>%
  select(-GO) %>%
  group_by(ORF, category) %>%
  slice(1) %>%
  tidyr::spread(category, geneset) %>%
  select(
    ORF, common, SGD, class,
    cellular_compartment = C,
    molecular_function = F,
    biological_process = P
  ) %>%
  ungroup()

feature_metadata <- gasche_2000 %>%
  select(UID) %>%
  left_join(goslim_mappings, by = c("UID" = "ORF"))
```

#### Samples

```{r}
library(stringr)

experiment_labels <- tibble::tibble(sample = colnames(gasche_matrix)) %>%
  mutate(experiment = case_when(
    str_detect(sample, "hs\\-1") ~ "Heat Shock (A) (duration)",
    str_detect(sample, "hs\\-2") ~ "Heat Shock (B) (duration)",
    str_detect(sample, "^37C to 25C") ~ "Cold Shock (duration)",
    str_detect(sample, "^heat shock") ~ "Heat Shock (severity)",
    str_detect(sample, "^29C to 33C") ~ "29C to 33C (duration)",
    str_detect(sample, "^29C \\+1M sorbitol to 33C \\+ 1M sorbitol") ~ "29C + Sorbitol to 33C + Sorbitol (duration)",
    str_detect(sample, "^29C \\+1M sorbitol to 33C \\+ \\*NO sorbitol") ~ "29C + Sorbitol to 33C (duration)",
    str_detect(sample, "^constant 0.32 mM H2O2") ~ "Hydrogen peroxide (duration)",
    str_detect(sample, "^1 ?mM Menadione") ~ "Menadione (duration)",
    str_detect(sample, "^2.5mM DTT") ~ "DTT (A) (duration)",
    str_detect(sample, "^dtt") ~ "DTT (B) (duration)",
    str_detect(sample, "diamide") ~ "Diamide (duration)",
    str_detect(sample, "^1M sorbitol") ~ "Sorbitol (duration)",
    str_detect(sample, "^Hypo-osmotic shock") ~ "Hypo-Osmotic Shock (duration)",
    str_detect(sample, "^aa starv") ~ "Amino Acid Starvation (duration)",
    str_detect(sample, "^Nitrogen Depletion") ~ "Nitrogen Depletion (duration)",
    str_detect(sample, "^[Dd]iauxic [Ss]hift") ~ "Diauxic Shift (duration)",
    str_detect(sample, "ypd-2") ~ "YPD (duration)",
    str_detect(sample, "ypd-1") ~ "YPD stationary phase (duration)",
    str_detect(sample, "overexpression") ~ "TF Overexpression",
    str_detect(sample, "car-1") ~ "Carbon Sources (A)",
    str_detect(sample, "car-2") ~ "Carbon Sources (B)",
    str_detect(sample, "ct-1") ~ "Temperature Gradient",
    str_detect(sample, "ct-2") ~ "Temperature Gradient, Steady State"
    )) %>%
  group_by(experiment) %>%
  mutate(experiment_order = 1:n()) %>%
  ungroup() %>%
  mutate(
    experiment_order = ifelse(is.na(experiment), NA, experiment_order),
    experiment = ifelse(is.na(experiment), "Other", experiment)
  )
```


### Formatting for romic

```{r}
# tidy gasche measurements
tall_gasche <- gasche_2000 %>%
  select(-NAME, -GWEIGHT) %>%
  tidyr::gather("sample", "expression", -UID)
  
triple_omic <- create_triple_omic(
  measurement_df = tall_gasche,
  feature_df = feature_metadata,
  sample_df = experiment_labels,
  feature_pk = "UID",
  sample_pk = "sample"
)
```


# Plotting At the Tips of Your Fingers

## Deploying a shiny app to shinyapps.io

```{r pcs}
triple_omic %>%
  triple_to_tidy() %>%
  app_pcs()
```


```{r}
# filter to a few experiments for the demo
heatshock_triple_omic <- triple_omic %>%
  filter_tomic(
    filter_type = "category",
    filter_table = "samples",
    filter_variable = "experiment",
    filter_value = c(
      "Heat Shock (A) (duration)",
      "Heat Shock (B) (duration)",
      "Heat Shock (severity)",
      "Temperature Gradient"
      ))

app_heatmap(heatshock_triple_omic)
```
