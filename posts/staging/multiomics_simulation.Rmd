---
title: "Multi-Omics Simulation"
author: "Sean Hackett"
date: "3/8/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This notebook contains a generative process for a multi-omic regulatory network and a simulated dataset of genetic perturbation experiments.

Why is this helpful?
- The generated dataset can be trained to infer cause->effect relationships from dynamics that can then be compared to the true relationships in the regulatory network.
- We can mask certain molecular species (e.g., metabolites or proteins) so that they serve as unmeasured confounders. This can be used to evaluate causal inference methods sensitivity to mis-specification and can help to inform the overall value of collecting multiomic data (i.e., directly measure the metabolites and/or proteins).

A multi-omic regulatory network contains multiple different classes of molecules and a set of directed edges between regulators and targets reflecting causal relationships. In a single 'omic model we want to treat all species equivalently, but in a multiomic model it makes sense to mold the relationships between molecules to better reflect known molecular biology.

Factors to include a general simulation:

- transcripts:
  - regulated by proteins > metabolites 
  - modify their cognate protein
- proteins
  - regulated by cognate transcript > proteins = metabolites
- metabolites
  - This can include other chemical/physical "global effect" such as chromatin state or cellular pH. 
  - regulated by proteins and metabolites
  - modify proteins (structure or activity) >> transcripts

To create a network featuring such interactions, we can start with a Barabasi-Albert model. In this model, molecular species are added one at a time and each time a new species is added it creates N connections to existing species. Since species added earlier will have more chances of being selected by newly added species they become more highly connected, exhibiting preferential attachment. This results in an overall degree distribution which follows a power-law distribution (to make the physicists happy).

Updating this model so it conforms to the multiomics rules above can be done by pruning edges based on the overall feasibility of cross-class interactions and adding edges between all RNAs and the protein they encode.

To simulate dynamics from this network we can write ODEs for each molecular species where all regulators of a given species are represented as activators or inhibitors. Without care such ODEs can easily explode to $\infty$ or drop to $\le 0$. To avoid this, we can use saturable rate equations like convenience kinetics, along with basal synthesis rates, and first order decay. This allows us to find the derivative of each species based on the current levels of all species and causal effect sizes.

Iterating this system forward finds a steady-state of stable molecule abundances. We can then increase the basal synthesis of any given molecular species to create a synthetic induction experiment.

```{r env_setup, message = FALSE}
library(dplyr)
library(ggplot2)
library(ggraph) # to plot network elements
```

```{r}
n_genes <- 100
metab_frac <- 0.3
n_metabolites <- n_genes * 0.3
n_species <- n_genes * 2 + n_metabolites # genes are doubled up because: 1 transcript + 1 protein

net_connections <- igraph::sample_pa(n_species,
                                     power = 1,
                                     m = 2)
```

```{r}
edge_counts <- igraph::degree(net_connections) %>%
  table() %>%
  {tibble::tibble(degree = names(.),
                  count = unname(.))} %>%
  dplyr::mutate_all(as.integer)

ggplot(edge_counts, aes(x = degree, y = count)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  ggtitle("Yay powerlaws")
```

## Assign simulated nodes to molecules

```{r}
species_init <- dplyr::bind_rows(
  tibble::tibble(gene_id = 1:n_genes,
                 species_type = "transcript"),
  tibble::tibble(gene_id = 1:n_genes,
                 species_type = "protein"),
  tibble::tibble(gene_id = NA_integer_,
                 species_type = rep("metabolite", n_metabolites))
) %>%
  dplyr::mutate(species_id = sample(1:n_species))

# edge_plausibility
edge_plausibility <- tibble::tribble(~ from_type, ~ to_type, ~ interaction_type, ~ plausibility,
                "transcript", "transcript", NA_character_, 0,
                "transcript", "protein", NA_character_, 0,
                "transcript", "metabolite", NA_character_, 0,
                "protein", "transcript", "TF", 1,
                "protein", "protein", "PPI", 0.5,
                "protein", "metabolite", "enzyme", 1,
                "metabolite", "transcript", "MDI", 0.2,
                "metabolite", "protein", "MPI", 1,
                "metabolite", "metabolite", "interconversion", 1)
                
edges_df <- igraph::as_data_frame(net_connections) %>%
  tibble::as_tibble() %>%
  dplyr::rename(from = to, to = from) %>%
  dplyr::mutate_all(as.integer) %>%
  dplyr::left_join(species_init %>%
                    dplyr::select(from = species_id, from_type = species_type),
                  by = "from") %>%
  dplyr::left_join(species_init %>%
                    dplyr::select(to = species_id, to_type = species_type),
                  by = "to") %>%
  dplyr::left_join(edge_plausibility, by = c("from_type", "to_type")) %>%
  # cull edges based on plausibility
  dplyr::filter(plausibility != 0) %>%
  dplyr::group_by(from, interaction_type) %>%
  dplyr::mutate(plausible = sample(c(TRUE, FALSE), size = 1, prob = c(plausibility[1], 1-plausibility[1]))) %>%
  dplyr::ungroup() %>%
  dplyr::filter(plausible) %>%
  dplyr::select(from, to, interaction_type) %>%
  # add cognate edges
  dplyr::bind_rows(
    species_init %>%
      dplyr::filter(species_type != "metabolite") %>%
      tidyr::spread(species_type, species_id) %>%
      dplyr::select(from = transcript, to = protein) %>%
      dplyr::mutate(interaction_type = "cognate")
  )
  
species_df = species_init %>%
  dplyr::select(species_id, species_type) %>%
  dplyr::arrange(species_id) %>%
  # add some global properties which can be configured to be feature-specific
  dplyr::mutate(
    basal_prod = 0.2,
    loss_rate = 1
  )

pruned_network <- igraph::graph_from_data_frame(edges_df,
                                                directed = TRUE,
                                                vertices = species_df)
```

```{r}
edges_df %>%
  dplyr::count(interaction_type) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "left")
```

```{r}
work_with_top_cluster <- TRUE
if (work_with_top_cluster) {
  network_clusters <- igraph::clusters(pruned_network)
  isolated_vertices <- names(network_clusters$membership)[network_clusters$membership != which.max(network_clusters$csize)]
  
  pruned_network <- igraph::delete_vertices(pruned_network, isolated_vertices)
}

ggraph(pruned_network, layout = "kk") +
  geom_edge_link(arrow = arrow(type = "closed", length = unit(0.07, "inches")), color = "gray50", alpha = 0.5) +
  geom_node_point(aes(color = species_type)) +
  scale_color_brewer("Species Type", palette = "Set2") +
  theme_void() +
  theme(legend.position = "bottom")
```

## Simulating a dynamic dataset

$$
\frac{dS_{i}}{dt} = \sum_{j}\alpha_{ji}S_{j} + C - \lambda S_{i}
$$
This is no good, values -> < 0

$$
\frac{dS_{i}}{dt} = C e^{\sum_{j}\alpha_{ji}S_{j}} - \lambda S_{i}
$$
This is no good, values blow up to Inf

$$
\frac{dS_{k}}{dt} = \prod_{i \in \text{inhibitors}} \frac{k_i}{k_{i} + S_i}\prod_{a \in \text{activators}} \left( 1 + \frac{S_{a}}{k_{a}}\right) - \lambda S_{k}
$$


```{r}
library(deSolve)

reffect <- function (n, mean = 0.5, shape = 10) {
  magnitudes <- rgamma(n, shape = shape, scale = mean / shape)
  effect <- magnitudes * (rbinom(n, 1, 0.5) - 0.5)*2
}

states <- rep(1, nrow(species_df))

pars <- edges_df %>%
  dplyr::mutate(
    effect = reffect(n()),
    effect = ifelse(interaction_type == "cognate", abs(effect), effect),
    # transform to Ka and Kd for saturable rate equations
    act_or_inh = ifelse(effect < 0, "inhibitor", "activator"),
    dissoc_constant = exp(effect)
  )
    
ggplot(pars, aes(x = effect, fill = interaction_type)) +
  geom_histogram(binwidth = 0.1) 
  

Deffects <- function(time, states, pars, species_df, time_resolution = 0.1) {
  
  # takes the args of ode() and returns derivatives
  # aligned with "states"
  
  reg_states <- tibble::tibble(value = states) %>%
    dplyr::mutate(species_id = 1:n()) %>%
    dplyr::left_join(species_df, by = "species_id")
  
  modulated <- pars %>%
    dplyr::left_join(reg_states, by = c("from" = "species_id")) %>%
    dplyr::mutate(rel_rate = dplyr::case_when(
      act_or_inh == "inhibitor" ~  dissoc_constant / (dissoc_constant + value),
      act_or_inh == "activator" ~  1 + value / dissoc_constant
      )) %>%
    dplyr::group_by(to) %>%
    dplyr::summarize(rate = prod(rel_rate))
  
  reg_states <- reg_states %>%
    dplyr::left_join(modulated, by = c("species_id" = "to")) %>%
    dplyr::mutate(rate = ifelse(is.na(rate), 1, rate),
                  loss = -1 * value * loss_rate,
                  # basal production + variable production + washout
                  # scale to time resolution / step size
                  deriv = (basal_prod + rate + loss)*time_resolution)
  
  state_derivs <- list(reg_states$deriv)
  
  return (state_derivs)
  
}
```

```{r}
# since production and degradation rates are not balanced initially
# we can simulate from initial conditions to find pre-perturbation initial steady state
MAX_TIME <- 1000
TIME_RESOLUTION <- 0.5

ode_sim <- ode(
  y = states,
  times = seq(0, MAX_TIME, by = TIME_RESOLUTION),
  func = Deffects,
  parms = pars,
  species_df = species_df
  )

simulated_dynamics <- ode_sim %>%
  as.data.frame() %>%
  tidyr::gather(species_id, value, -time) %>%
  tibble::as_tibble() %>%
  dplyr::mutate(species_id = as.integer(species_id))

simulated_dynamics %>%
  dplyr::semi_join(
    simulated_dynamics %>%
      dplyr::distinct(species_id) %>%
      dplyr::sample_n(10),
    by = "species_id"
  ) %>%
  ggplot(aes(x = time, y = value)) +
  geom_path() +
  facet_wrap(~ species_id, scale = "free_y")
  
# check for a steady state
time_derivatives <- simulated_dynamics %>%
  dplyr::filter(time > max_time - 1) %>%
  dplyr::arrange(time) %>%
  tidyr::nest(vals = -species_id) %>%
  dplyr::mutate(assym_summary = purrr::map(
    vals,
    function(x) {
      tibble::tibble(
        assym_value = mean(x$value),
        # check differences between adjacent time steps
        mean_D = mean(diff(x$value))
      )
      }
  )) %>%
  dplyr::select(-vals) %>%
  tidyr::unnest(assym_summary)

stopifnot(
  all(!is.na(time_derivatives$mean_D)),
  all(abs(time_derivatives$mean_D) < 1e-5)
  )
```

### Now we can take the steady-state and add a genetic perturbation

```{r}
# now lets separately perturb each species

simulate_perturbation <- function (perturbed_species_id, time_derivatives, species_df) {
  
  checkmate::assertInteger(perturbed_species_id)
  checkmate::assertChoice(perturbed_species_id, species_df$species_id)
  
  perturbed_species_df <- species_df %>%
    dplyr::mutate(basal_prod = ifelse(species_id == perturbed_species_id, basal_prod*20, basal_prod))
    
  perturbation_sim <- ode(
    y = time_derivatives$assym_value,
    times = seq(0, 100, by = 0.5),
    func = Deffects,
    parms = pars,
    species_df = perturbed_species_df
  ) %>%
    as.data.frame() %>%
    tidyr::gather(species_id, value, -time) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(species_id = as.integer(species_id)) %>%
    dplyr::group_by(species_id) %>%
    # calculate fold-change relative to the t0 s.s.
    dplyr::mutate(fold_change = value / value[time == 0]) %>%
    dplyr::ungroup()
}

ggplot(perturbation_sim, aes(x = time, y = log2(fold_change), group = species_id)) +
  geom_path()

all_perturbation_timecourses <- time_derivatives %>%
  dplyr::distinct(perturbed_species_id = species_id) %>%
  dplyr::mutate(perturbation_results = purrr::map(
    perturbed_species_id,
    simulate_perturbation, 
    time_derivatives,
    species_df
    ) 
  )

all_perturbation_timecourses %>%
  tidyr::unnest(perturbation_results) %>%
  dplyr::semi_join(
    pars,
    by = c("perturbed_species_id" = "from", "species_id" = "to")
    ) %>%
  dplyr::mutate(tc_id = glue::glue("{perturbed_species_id}_{species_id}")) %>%
  ggplot(aes(x = time, y = fold_change, group = tc_id)) +
  geom_path() +
  ggtitle("Direct activation / inhibition")
  




```

